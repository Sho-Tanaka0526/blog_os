標準ライブラリの無効化
リンクしている標準ライブラリを解除して使用不可能にする
> #![no_std]

エラーが発生する
> error: `#[panic_handler]` function required, but not found      //#[panic_handler]関数が存在しません
> error: language item required, but not found: `eh_personality`  //language itemが存在しません

Panicの実装
標準ならば実装されるパニックハンドラー関数を定義、実装する
>#[panic_handler]
eh_personality Language Item
language itemコンパイラによって内部的に必要とされる特別な関数や型のこと
Copyトレイとにはlanguage itemとして定義されている特別な#[lang = "copy"] attributeを持っていることがわかる

eh_personality language はスタックアンワインドを実装するための関数を定義する
パニックが起きた場合にはデフォルトとして、Rustはアンワインドを使用してすべてのスタックにある変数のデストラクタを実行する
しかし複雑なため無効化する
Cargo.tomlファイルに追加する
>[profile.dev]
>panic = "abort"
>[profile.release]
>panic = "abort"

コンパイルしようとすると別のエラーが発生する
>error: requires `start` lang_item
エントリポイントを定義するstart language itemが存在しない

start attribute
main関数はプログラムを実行したときに最初に呼び出される関数であると考えられる
しかしほとんどの言語にはランタイムシステムがあり、ガーベジコレクションやソフトウェアスレッドなどを処理する
ランタイムは自信を初期化する必要があるためmain関数の前に呼び出す必要がある
スタック領域の作成と正しいレジスタへの引数の配置が含まれる

標準ライブラリをリンクする一般的なRustバイナリでは、crt0("C runtime zero")と呼ばれるCのランタイムライブラリで実行が開始され、Capurike-shonnnokankyougasetteisareru 
その後Cランタイムは、start language itemで定義されているRustランタイムのエントリポイントを呼び出す
スタックオーバーフローを防ぐ設定やパニック時のバックトレースの表示などいくつかの小さな処理を行い、最後にmain関数を呼び出す

今のところ編集しているファイルではRustランタイムとcrt0へのアクセスができない
そのためエントリポイントを定義する必要がある
start language itemを実装することはcrt0を必要とするので不可能
代わりにcrt0エントリポイントを直接上書きする

エントリポイントの上書き
Rustコンパイラに通常のエントリポイントを使いたくないことを伝えるために、#![no_main] attributeを追加する

main関数を呼び出す基盤となるランタイムなしにはおいていても意味がないため代用としてOSのエントリポイントを独自の_start関数で上書きする

Rustコンパイラが_startという名前の関数を実際に出力するように、#[no_mangle] attributeを用いて名前修飾を無効にする
このattributeがないとコンパイラがすべての関数にユニークな名前を付けるために、シンボルを作成する
次のステップでエントリポイントとなる関数の名前をリンカに伝えるためこの属性が必要となる

Cの呼び出し規約を使用するようコンパイラに伝えるために関数をextern "C"として定義する必要がある
_startという名前の理由はこれがほとんどのシステムのデフォルトのエントリポイント名のため

戻り値の型である!は関数が発散している、つまり値を返すことができないことを意味している
エントリポイントはどの関数からも呼び出されず、OSまたはブートローダーから直接呼び出されるので、これは必須となる
値を返す代わりにエントリポイントはたとえばOSのexitシステムコールを呼び出す
今回はマシンをシャットダウンするようにするとよいため今のところ無限ループを発生させる

cargo buildすると見づらいリンカエラーが発生する

リンカエラー
リンカは、生成されたコードを実行可能ファイルに紐づけるプログラムのこと
実行可能ファイルの形式はOSごとに異なるためそれぞれ異なるエラーを発生させる独自の隣家がある
エラーの根本的な原因は同じ
隣家のデフォルト設定ではプログラムがCランタイムに依存していると仮定しているが実際にはしていないため
エラーを回避するためにリンカにCランタイムに依存しないことを伝える必要がある
リンカに一連の引数を渡すかベアメタルターゲット用にビルドすることで可能となる

今回はベアメタルターゲット用にビルドする方法を用いる
様々な環境を表現するために、Rustはtarget tripleという文字列を使う
rustc --version --bervoseを実行してホストシステムのtarget tripleを確認する
>rustc 1.68.2 (9eb3afe9e 2023-03-27)
>binary: rustc
>commit-hash: 9eb3afe9ebe9c7d2b84b71002d44f4a0edac95e0
>commit-date: 2023-03-27
>host: x86_64-pc-windows-msvc
>release: 1.68.2
>LLVM version: 15.0.6

hostはx86_64-pc-windows-msvc
これにはCPUアーキテクチャ(x86_64)、ベンダー(pc)。OS(windows)、そしてABI(msvc)が含まれている

ホストのtriple用にコンパイルすることで、Rustコンパイラとリンカは、でおfるとでCランタイムを使用するLinuxやWindowsのような基盤となるOSがあると想定し、それによってリンカエラーが発生する
回避するために基盤となるOSを使用せずに異なる環境用にコンパイルする

ベアメタル環境の例としては、thumbv7em-none-eabihf target tripleがある
これは、組込みシステムを表している
詳細は省くが、noneという文字列からわかるようにこのtarget tripleに基盤となるOSが存在しないこと
このターゲット用にコンパイルできるようにするにはrustupにこれを追加する必要がある
>rustup target add thumbv7em-none-eabihf
これによりこのtarget triple用の標準(およびコア)ライブラリのコピーがダウンロードされる
これでこのターゲット用にフリースタンディングな実行可能ファイルをビルドできる
>cargo build --target thumbv7em-none-eabihf
--target引数を渡すことでベアメタルターゲット用に実行可能ファイルをクロスコンパイルする
このターゲットシステムにはOSがないため、リンカはCランタイムをリンクしようとせず、ビルドはリンカエラーなしで成功する

最小限の独立したRustバイナリ
src/main.rs:
>#![no_std] // Rust の標準ライブラリにリンクしない
>#![no_main] // 全ての Rust レベルのエントリポイントを無効にする
>
>use core::panic::PanicInfo;
>
>#[no_mangle] // この関数の名前修飾をしない
>pub extern "C" fn _start() -> ! {
>    // リンカはデフォルトで `_start` という名前の関数を探すので、
>    // この関数がエントリポイントとなる
>    loop {}
>}
>
>/// この関数はパニック時に呼ばれる
>#[panic_handler]
>fn panic(_info: &PanicInfo) -> ! {
>    loop {}
>}

Cargo.toml:
>[package]
>name = "crate_name"
>version = "0.1.0"
>authors = ["Author Name <author@example.com>"]
>
># the profile used for `cargo build`
>[profile.dev]
>panic = "abort" # disable stack unwinding on panic
>
># the profile used for `cargo build --release`
>[profile.release]
>panic = "abort" # disable stack unwinding on panic

このバイナリをビルドするために、thumbv7em-none-eabihfのようなベアメタルターゲット用にコンパイルする必要がある
>cargo build --target thumbv7em-none-eabihf

あるいは追加のリンカ引数を渡してホストシステム用にコンパイルすることもできる
#windows
>cargo rustc -- -C link-args="/ENTRY:_start /SUBSYSTEM:console"
これは独立したRustバイナリの最小の例に過ぎない
_start関数が呼び出されたときにスタックが初期化されるなど、様々なことを前提としている
そのため、このようなバイナリを実際に使用するには、より多くの手順が必要となる

----------
Rustで作る最小のカーネル
★carnel branchを作成、変更した
ページが終わり次第margeする

起動のプロセス
コンピュータを起動すると、マザーボードのROMに保存されたファームウェアのコードを実行し始める
このコードは、起動時の自己テスト(power-on self test)を実行し、使用可能なRAMを検出、CPUとハードウェアを事前初期化(pre-initialize)する
ファームウェアには2種類ある
BIOSとUEFI
今回はBIOSを使う

BIOSの起動
ほぼすべてのx86システムがBIOSによる起動をサポートしている
これは近年のUEFIベースのマシンも例外ではなくエミュレートされたBIOSを使用している
ブートローダーを動かすためにCPUがリアルモード(real mode)と呼ばれる16bit互換モードにされてしまう

コンピュータは起動時にマザーボード上にある特殊なフラッシュメモリからBIOSを読み込む
BIOSは自己テストとハードウェアの初期化ルーチンを実行し、ブータブルディスクを探す
ディスクが見つかると、ブートローダーと呼ばれる、その先頭512バイトに保存された実行可能コードへと操作権が移る
ブートローダーはディスク内のカーネルイメージの場所を特定し、メモリに読み込まなければならない
またCPUを16bitのリアルモードから32bitのプロテクトモード(protect mode)へ、そして64bitのロングモード(long mode)へと変更しなければならない
64bitレジスタとすべてのメインメモリが利用可能となる
3つ目の仕事は、特定の情報(例えばメモリーマップなど)をBIOSから聞き出し、OSのカーネルに渡すこと

ブートローダーを書くのにはアセンブリ言語を必要とするうえ、「何も考えずにプロセッサのこのレジスタに値を書き込んでください」のような勉強の役に立たない作業がたくさんあるため今回は飛ばす
代わりにbootimageという、自動でカーネルの前にブートローダーを置いてくれるツールを使う

Multiboot標準規格
すべてのオペレーティングシステムが、jひ鍼にのみ対応しているブートローダーを実装するということを避けるために、1995年にフリーソフトウェア財団がMultibootというブートローダーの公開標準規格を策定している
今回は問題が多いため使用しない

最小のカーネル
理解したうえで、自前で最小のカーネルを書いてみる
目標は起動したら画面に"Hello, World!"と出力するようなディスクイメージを作ること

cargoを使ってビルドしたが、オペレーティングシステムに依って異なるエントリポイント名とコンパイルフラグが必要だった
cargoが標準ではホストシステムに向けてビルドするためである
明確に定義されたターゲットシステム向けにコンパイルできれば理想的

RustのNightly版をインストールする
>https://teratail.com/questions/326468
rust-toolchainというファイルにnightlyと記述、ルートディレクトリに設置してNightlyにする
feature flagをファイルの先頭につけることで、いろいろな実験的機能を使うことを選択できる
例えば #![feature(asm)] をmain.rsの先頭につけることで、インラインアセンブリのための実験的なasm!マクロを有効化できる
これらの実験的機能はまったくもって不安定(unstable)であり、将来のRustバージョンにおいては事前の警告なく変更されたり取り除かれたりする

ターゲットの使用
Cargoは--targetパラメータを使用して様々なターゲットをサポートする
ターゲットはいわゆるtarget triple(3つ組)によってあらわされる
これはCPUアーキテクチャ、製造元、オペレーティングシステム、そしてABIを表す
x86_64-unknown-linux-gnuというtarget tripleはx86_64のCPU、製造元不明、GNU ABIのLinuxオペレーティングシステム向けのシステムを表す
Rustは多くのtarget tripleをサポートしていてその中にはAndroidのためのarm-linux-androideabiやWebAssemblyのためのwasm32-unknown-unknownなどがある

今回のカーネルはx86_64のシステムをターゲットとするため共通する要素を埋めるところから始める
ベアメタル環境で実行するため、llvm-targetのOSを変更し、OSフィールドをnoneにしておく
ビルドに関係する項目を追加する
プラットフォーム標準のリンカではなく、Rustに付属しているクロスプラットフォームのLLDリンカを使用する
>"linker-flavor": "ld.lld",
>"linker": "rust-lld",
この設定はターゲットがパニック時のstack unwindingをサポートしていないため、プログラムは代わりに直接中断(abort)しなければならないことを指定している
>"panic-strategy": "abort",
カーネルを書いている以上、ある時点で割込み(innerrupt)を処理しなければならない
これを安全に行うために"red zone"と呼ばれる、ある種のスタックポインタ最適化を無効化する必要がある
これをしないとスタックの破損を引き起こしてしまう恐れがあるため
>"features": "-mmx,-sse,+soft-float",
featuresフィールドは、ターゲットの機能を有効か/無効化する
マイナスをつけることでmmxとsseという機能を無効化、プラスをつけることでsoft-floatという機能を有効化している

カーネルをビルドする
私たちの新しいターゲットのコンパイルはLinuxの慣習に倣う
_startという名前のエントリポイントが要るということ

ホストOSが何であるかにかかわらず、エントリポイントは_startという名前でなければならないことに注意する
これで新しいターゲットのためのカーネルを、JSONファイル名を--targetとして渡すことでビルドできるようになる
失敗しましたね！
エラーはRustコンパイラがcoreライブラリを見つけられなくなったと言っている
このライブラリにはResultやOption、イテレータのような基本的なRustの型を持っており、暗黙のうちにすべてのno_stdなクレートにリンクされている

問題は、coreライブラリはRustコンパイラと一緒にコンパイル済み(precompiled)ライブラリとして配布されているということ
そのためサポートされているhost triple(例えば x86_64-unknown-linux-gnu)でのみ使える
coreのターゲットを他に向けて再コンパイルする必要がある

build-stdオプション
ここでcargoのbuild-std機能を利用する
これを使うとcoreやその他の標準ライブラリクレートについて、Rustインストール時に一緒についてくるコンパイル済みバージョンを使う代わりに、必要に応じて再コンパイルすることができる
これはとても新しくまだ完成していないため不安定機能(unstable)とされており、nightly Rustコンパイラでのみ利用ができる

このファイルはcargoにcoreとcompiler_builtinsライブラリを再コンパイルするように命令する
後者が必要なのはcoreがこれに依存しているため
これらのライブラリを再コンパイルするためには、cargoがRustのソースコードにアクセスできる必要がある
これはrustup component add rust-srcでインストールできる

unstable.build-std設定キーをセットして、rust-srcコンポーネントをインストールしたらビルドコマンドをもう一度実行する
今回はcargo buildがcore、rustc-std-workspace-core(compiler_builtinsの依存)、そしてcompiler_builtinsを私たちのカスタムターゲット向けに再コンパイルしていることがわかる

quemアプリをwindowsにインストール
quemのあるフォルダにblog_os.binを移動
以下のコマンドで強引にbootimageファイルをtarget指定してqemu-systemx86_64.exeを起動
C:\Program Files\qemu> .\qemu-system-x86_64.exe -drive format=raw,file=.\bootimage-blog_os.bin
